<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>PI Adapter for Modbus TCP data selection configuration </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="PI Adapter for Modbus TCP data selection configuration ">
    <meta name="generator" content="docfx 2.56.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../../V1/index.html" width="46">
                <img id="logo" src="../../V1/main/V1/images/atlas_icon.png" height="46" width="46" alt="OSIsoft Edge System"> 
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="PIAdapterForModbusTCPDataSelectionConfiguration">
<h1 id="pi-adapter-for-modbus-tcp-data-selection-configuration">PI Adapter for Modbus TCP data selection configuration</h1>

<p>In addition to the data source configuration, you need to provide a data selection configuration to specify the data you want the adapter to collect from the data sources.</p>
<h2 id="configure-modbus-tcp-data-selection">Configure Modbus TCP data selection</h2>
<p>You cannot modify Modbus TCP data selection configurations manually. You must use the REST endpoints to add or edit the configuration.</p>
<p>Complete the following steps to configure the Modbus TCP data selection:</p>
<ol>
<li>Use any text editor to create a file that contains a Modbus TCP data selection in the JSON format.<ul>
<li>For content structure, see <a href="#modbus-tcp-data-selection-examples">Modbus TCP data selection examples</a>.</li>
<li>For a table of all available parameters, see <a href="#modbus-tcp-data-selection-parameters">Modbus TCP data selection parameters</a>.</li>
</ul>
</li>
<li>Save the file. For example, <code>ConfigureDataSelection.json</code>.</li>
<li><p>Use any of the <a class="xref" href="../main/V1/Configuration/configuration-tools.html">Configuration tools</a> capable of making HTTP requests to run either a <code>POST</code> or <code>PUT</code> command to their appropriate endpoint:</p>
<p> <strong>Note:</strong> The following examples use Modbus1 as the adapter component name. For more information on how to add a component, see <a class="xref" href="../main/V1/Configuration/system-components-configuration.html">System components configuration</a>.</p>
<p> <code>5590</code> is the default port number. If you selected a different port number, replace it with that value.</p>
<ul>
<li><p><strong>POST</strong> endpoint: <code>http://localhost:5590/api/v1/configuration/&lt;componentID&gt;/DataSelection/</code></p>
<p>Example using <code>curl</code>:</p>
<p><strong>Note:</strong> Run this command from the same directory where the file is located.</p>
<pre><code class="lang-bash">curl -d &quot;@ConfigureDataSelection.json&quot; -H &quot;Content-Type: application/json&quot; -X POST &quot;http://localhost:5590/api/v1/configuration/Modbus1/DataSelection&quot;
</code></pre></li>
<li><p><strong>PUT</strong> endpoint: <code>http://localhost:5590/api/v1/configuration/&lt;componentID&gt;/DataSelection/&lt;ID&gt;</code></p>
<p>Example using <code>curl</code>:</p>
<p><strong>Note:</strong> Run this command from the same directory where the file is located.</p>
<pre><code class="lang-bash">curl -d &quot;@DataSelection.config.json&quot; -H &quot;Content-Type: application/json&quot; -X PUT &quot;http://localhost:5590/api/v1/configuration/Modbus1/DataSelection/DataItem1&quot;
</code></pre></li>
</ul>
</li>
</ol>
<h2 id="modbus-tcp-data-selection-schema">Modbus TCP data selection schema</h2>
<p>The full schema definition for the Modbus data selection configuration is in the <code>Modbus_DataSelection_schema.json</code> file located in one of the following folders:</p>
<p>Windows: <code>%ProgramFiles%\OSIsoft\Adapters\Modbus\Schemas</code></p>
<p>Linux: <code>/opt/OSIsoft/Adapters/Modbus/Schemas</code></p>
<h2 id="modbus-tcp-data-selection-parameters">Modbus TCP data selection parameters</h2>
<p>The following parameters are available to configure a Modbus TCP data selection:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Required</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DeviceId</strong></td>
<td>Required</td>
<td><code>string</code></td>
<td>Specifies the DataSource device that this data selection item is read from. The value must match one of the <code>&lt;Id&gt;</code> values specified in the DataSource <a class="xref" href="pi-adapter-for-modbus-tcp-data-source-configuration.html#devices">Devices</a> configuration.</td>
</tr>
<tr>
<td><strong>Selected</strong></td>
<td>Optional</td>
<td><code>boolean</code></td>
<td>Selects or clears a measurement. To select an item, set to <code>true</code>. To remove an item, leave the field empty or set to false.  <br><br>Allowed value: <code>true</code> or <code>false</code><br>Default value: <code>true</code></td>
</tr>
<tr>
<td><strong>Name</strong></td>
<td>Optional</td>
<td><code>string</code></td>
<td>The optional friendly name of the data item collected from the data source. <br><br>Default value: stream ID</td>
</tr>
<tr>
<td><strong>UnitId</strong></td>
<td>Required</td>
<td>number</td>
<td>Modbus TCP slave device unit ID. <br><br>Minimum value: <code>0</code><br> Maximum value: <code>247</code></td>
</tr>
<tr>
<td><strong>RegisterType</strong></td>
<td>Required</td>
<td>number or <code>string</code></td>
<td>Modbus TCP register type. Supported types are <code>Coil</code>, <code>Discrete</code>, <code>Input16</code>, <code>Input32</code>, <code>Holding16</code> and <code>Holding32</code>.<br><br><code>Input16</code> and <code>Holding16</code> are used to read registers that have a size of 16 bits. For registers that have a size of 32 bits, use the <code>Input32</code> and <code>Holding32</code> register types. To represent the types, you can type in the register type ID or the exact name: <br><br>Allowed values:<br><code>1</code> or <code>Coil</code> (Read Coil Status)<br><code>2</code> or <code>Discrete</code> (Read Discrete Input Status)<br><code>3</code> or <code>Holding16</code> (Read 16-bit Holding Registers)<br><code>4</code> or <code>Holding32</code> (Read 32-bit Holding Registers)<br><code>6</code> or <code>Input16</code> (Read 16-bit Input Registers)<br><code>7</code> or <code>Input32</code> (Read 32-bit Input Registers)<br><br>For more information, see <a href="#register-types">Register types</a>.</td>
</tr>
<tr>
<td><strong>RegisterOffset</strong></td>
<td>Required</td>
<td>number</td>
<td>The 0 relative offset to the starting register for this measurement. For example, if your Holding registers start at base register 40001, the offset to this register is 0. For 40002, the offset to this register is 1.</td>
</tr>
<tr>
<td><strong>DataTypeCode</strong></td>
<td>Required</td>
<td>number</td>
<td>An integer representing the data type that the adapter will read starting at the register specified by the offset. <br><br> Supported data types:<br><code>1</code> = <code>Boolean</code><br><code>10</code> = <code>Int16</code><br><code>20</code> = <code>UInt16</code><br><code>30</code> = <code>Int32</code><br><code>31</code> = <code>Int32ByteSwap</code><br><code>100</code> = <code>Float32</code><br><code>101</code> = <code>Float32ByteSwap</code><br><code>110</code> = <code>Float64</code><br><code>111</code> = <code>Float64ByteSwap</code><br><code>1001</code> - <code>1250</code> = <code>String</code> <br><code>2001</code> - <code>2250</code> = <code>StringByteSwap</code></td>
</tr>
<tr>
<td><strong>ScheduleId</strong></td>
<td>Required</td>
<td><code>string</code></td>
<td>The ID of an existing schedule for reading values.</td>
</tr>
<tr>
<td><strong>BitMap</strong></td>
<td>Optional</td>
<td><code>string</code></td>
<td>The bitmap is used to extract and reorder bits from a word register. The format of the bitmap is uuvvwwxxyyzz, where uu, vv, ww, yy, and zz each refer to a single bit. A leading zero is required if the referenced bit is less than 10. The low-order bit is 01 and high-order bit is either 16 or 32. Up to 16 bits can be referenced for a 16-bit word (data types 10 and 20) and up to 32 bits can be referenced for a 32-bit word (data type 30 and 31). The bitmap 0307120802 maps the second bit of the original word to the first bit of the new word, the eighth bit to the second bit, the twelfth bit to the third bit, and so on. The high-order bits of the new word are padded with zeros if they are not specified.</td>
</tr>
<tr>
<td><strong>ConversionFactor</strong></td>
<td>Optional</td>
<td>number</td>
<td>Use this numerical value to scale the raw response received from the Modbus TCP device. If you specify ConversionFactor, regardless of the specified data type, the value is promoted to a float32 (single) when stored. [Result = (Value / Conversion Factor)]</td>
</tr>
<tr>
<td><strong>ConversionOffset</strong></td>
<td>Optional</td>
<td>number</td>
<td>Use this numerical value to apply an offset to the response received from the Modbus TCP device. If you specify ConversionOffset, regardless of the specified data type, the value is promoted to a float32 (single) when stored.  [Result = (Value - Conversion Offset)]</td>
</tr>
<tr>
<td><strong>DataFilterId</strong></td>
<td>Optional</td>
<td><code>string</code></td>
<td>If you want data filtering for this data selection item, specify the name of an existing data filter. If you do not specify the value or set it to <code>null</code>, all values read are output without being filtered.</td>
</tr>
<tr>
<td><strong>StreamID</strong></td>
<td>Optional</td>
<td><code>string</code></td>
<td>The custom stream ID that is used to create the streams. If you do not specify the StreamID, the adapter generates a default stream ID based on the measurement configuration. A properly configured custom stream ID follows these rules:<br><br>Is not case-sensitive.<br>Can contain spaces.<br>Cannot start with two underscores (&quot;__&quot;).<br>Can contain a maximum of 100 characters.<br>Cannot use the following characters:<br> <code>/</code> <code>:</code> <code>?</code> <code>#</code> <code>[</code> <code>]</code> <code>@</code> <code>!</code> <code>$</code> <code>&amp;</code> <code>&#39;</code> <code>(</code> <code>)</code> <code>\</code> <code>*</code> <code>+</code> <code>,</code> <code>;</code> <code>=</code> <code>%</code> <code>&lt;</code> <code>&gt;</code> or the vertical bar<br>Cannot start or end with a period.<br>Cannot contain consecutive periods.<br>Cannot consist of only periods.<br><br>The default ID automatically updates when there are changes to the measurement and follows the format of <code>&lt;DeviceId&gt;</code>.<code>&lt;UnitId&gt;</code>.<code>&lt;RegisterType&gt;</code>.<code>&lt;RegisterOffset&gt;</code>.</td>
</tr>
</tbody>
</table>
<p>Each JSON object in the file represents a measurement. You can modify the fields in each object to configure the measurement parameters. To add more measurements, you need to create more JSON objects with properly completed fields.</p>
<h3 id="register-types">Register types</h3>
<p>Register types are used to configure measurements in Modbus TCP data selection. The adapter supports six register types, corresponding to four function codes (1-4). Since one function code can return two types of registers, 16-bit or 32-bit depending on the device, either the register type or the register type code is required when configuring the data selection for the adapter.</p>
<p>The following table lists all the register types supported in the adapter.</p>
<table>
<thead>
<tr>
<th>Register Type</th>
<th>Register Type Code</th>
<th>Description</th>
<th>Function Code</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Coil</code></td>
<td><code>1</code></td>
<td>Read <code>Coil</code> Status</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>Discrete</code></td>
<td><code>2</code></td>
<td>Read <code>Discrete</code> Input Status</td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>Holding16</code></td>
<td><code>3</code></td>
<td>Read 16-bit Holding Registers</td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>Holding32</code></td>
<td><code>4</code></td>
<td>Read 32-bit Holding Registers</td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>Input16</code></td>
<td><code>6</code></td>
<td>Read 16-bit Input Registers</td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>Input32</code></td>
<td><code>7</code></td>
<td>Read 32-bit Input Registers</td>
<td><code>4</code></td>
</tr>
</tbody>
</table>
<p>When reading from function codes <code>1</code> and <code>2</code>, the adapter expects these to be returned as single bits. For function codes <code>3</code> and <code>4</code>, the adapter expects 16 bits to be returned from devices that contain 16-bit registers and 32 bits to be returned from devices that contain 32-bit registers.</p>
<h3 id="datatypecode">DataTypeCode</h3>
<h4 id="datatypecode-1">DataTypeCode 1</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>BoolModbus</td>
<td><code>Bool</code></td>
<td><code>Coil Discrete</code></td>
<td>0=Modbus0 / 1=Modbus1</td>
<td><code>bool</code></td>
<td>NA</td>
</tr>
</tbody>
</table>
<h4 id="datatypecode-10">DataTypeCode 10</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int16</td>
<td><code>Int16</code></td>
<td><code>Bool</code>/<code>16-bit</code></td>
<td>Read 1 Modbus register<sup>1</sup> and interpret as a 16-bit integer. Bytes [BA] read from the PLC are stored as [AB]. <sup>2</sup></td>
<td><code>Int16</code></td>
<td>1</td>
</tr>
</tbody>
</table>
<h4 id="datatypecode-20">DataTypeCode 20</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>UInt16</td>
<td><code>UInt16</code></td>
<td><code>Bool</code>/<code>16-bit</code></td>
<td>Read 1 Modbus register<sup>1</sup> and interpret as an unsigned 16-bit integer. Bytes [BA] read from the PLC are stored as [AB]. <sup>2</sup></td>
<td><code>Int32</code></td>
<td>11</td>
</tr>
</tbody>
</table>
<h4 id="datatypecode-30">DataTypeCode 30</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int32</td>
<td><code>Int32</code></td>
<td><code>16-</code>/<code>32-bit</code></td>
<td>Read 32-bits from the PLC and interpret as a 32-bit integer.  Bytes [DCBA] read from the PLC are stored as [ABCD]. <sup>2</sup></td>
<td><code>Int32</code></td>
<td>7</td>
</tr>
</tbody>
</table>
<h4 id="datatypecode-31">DataTypeCode 31</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Int32ByteSwap</td>
<td><code>Int32</code></td>
<td><code>16-</code>/<code>32-bit</code></td>
<td>Read 32-bits from the PLC and interpret as a 32-bit integer.  Bytes [BADC] read from the PLC are stored as [ABCD]. <sup>2</sup></td>
<td><code>Int32</code></td>
<td>7</td>
</tr>
</tbody>
</table>
<h4 id="datatypecode-100">DataTypeCode 100</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Float32</td>
<td><code>Float32</code></td>
<td><code>16-</code>/<code>32-bit</code></td>
<td>Read 32-bits from the PLC and interpret as a 32-bit float.  Bytes [DCBA] read from the PLC are stored as [ABCD]. <sup>2</sup></td>
<td><code>Float32</code></td>
<td>6</td>
</tr>
</tbody>
</table>
<h4 id="datatypecode-101">DataTypeCode 101</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Float32ByteSwap</td>
<td><code>Float32</code></td>
<td><code>16-</code>/<code>32-bit</code></td>
<td>Read 32-bits from the PLC and interpret as a 32-bit float.  Bytes [BADC] read from the PLC are stored as [ABCD]. <sup>2</sup></td>
<td><code>Float32</code></td>
<td>6</td>
</tr>
</tbody>
</table>
<h4 id="datatypecode-110">DataTypeCode 110</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Float64</td>
<td><code>Float64</code></td>
<td><code>16-</code>/<code>32-bit</code></td>
<td>Read 64-bits from the PLC and interpret as a 64-bit float.  Bytes [HGFEDCBA] read from the device are stored as [ABCDEFGH]. <sup>2</sup></td>
<td><code>Float64</code></td>
<td>6</td>
</tr>
</tbody>
</table>
<h4 id="datatypecode-111">DataTypeCode 111</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Float64ByteSwap</td>
<td><code>Float64</code></td>
<td><code>16-</code>/<code>32-bit</code></td>
<td>Read 64-bits from the PLC and interpret as a 64-bit float. Bytes [BADCFEHG] read from the device are stored as [ABCDEFGH]. <sup>2</sup></td>
<td><code>Float64</code></td>
<td>6</td>
</tr>
</tbody>
</table>
<h4 id="datatypecode-1001-1250">DataTypeCode 1001-1250</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td><code>String</code></td>
<td><code>16-</code>/<code>32-bit</code></td>
<td>1001 will a 1-character string, 1002 will read a 2-character string, 1003 will read a 3-character string and so on. Bytes [AB] are interpreted as &quot;AB&quot;.</td>
<td><code>String</code></td>
<td>101 to 199</td>
</tr>
</tbody>
</table>
<h4 id="datatypecode-2001-2250">DataTypeCode 2001-2250</h4>
<table>
<thead>
<tr>
<th>Name</th>
<th>Value Type</th>
<th>Register Type</th>
<th>Meaning</th>
<th>Output Type</th>
<th>Interface data type code</th>
</tr>
</thead>
<tbody>
<tr>
<td>StringByteSwap</td>
<td><code>String</code></td>
<td><code>16-</code>/<code>32-bit</code></td>
<td>2001 will a 1-character string, 2002 will read a 2-character string, 2003 will read a 3-character string and so on. Bytes [BA] are interpreted as &quot;AB&quot;.</td>
<td><code>String</code></td>
<td>101 to 199</td>
</tr>
</tbody>
</table>
<p><sup>1</sup> For more information about Modbus TCP registers, see <a href="https://www.se.com/us/en/faqs/FA168406/">How is data stored in Standard Modbus? (https://www.se.com/us/en/faqs/FA168406/)</a></p>
<p><sup>2</sup> Bytes are read in reverse order.</p>
<h2 id="modbus-tcp-data-selection-examples">Modbus TCP data selection examples</h2>
<p>The following are examples of valid Modbus TCP data selection configurations.</p>
<h3 id="minimal-data-selection-configuration">Minimal data selection configuration</h3>
<pre><code class="lang-json">[
    {
        &quot;DeviceId&quot; : &quot;Device1&quot;,
        &quot;Selected&quot; : true,
        &quot;UnitId&quot;: 1,
        &quot;RegisterType&quot;: 3,
        &quot;RegisterOffset&quot;: 122,
        &quot;DataTypeCode&quot;: 20,
        &quot;ScheduleId&quot;: &quot;Schedule1&quot;
    }
]
</code></pre><h3 id="complete-data-selection-configuration">Complete data selection configuration</h3>
<pre><code class="lang-json">[
    {
        &quot;DeviceId&quot; : &quot;Device1&quot;,
        &quot;Selected&quot;: true,
        &quot;Name&quot;: &quot;MyDataItem&quot;,
        &quot;UnitId&quot;: 1,
        &quot;RegisterType&quot;: 3,
        &quot;RegisterOffset&quot;: 123,
        &quot;DataTypeCode&quot;: 20,
        &quot;ScheduleId&quot;: &quot;Schedule1&quot;,
        &quot;StreamId&quot;: &quot;stream.1&quot;,
        &quot;BitMap&quot;: &quot;020301&quot;,
        &quot;ConversionFactor&quot;: 12.3,
        &quot;ConversionOffset&quot;: 14.5,
        &quot;DataFilterId&quot; : &quot;DataFilter1&quot;
    }
]
</code></pre><h2 id="rest-urls">REST URLs</h2>
<table>
<thead>
<tr>
<th>Relative URL</th>
<th>HTTP verb</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>api/v1/configuration/<em>ComponentId</em>/DataSelection</td>
<td><code>GET</code></td>
<td>Retrieves the Modbus TCP data selection configuration</td>
</tr>
<tr>
<td>api/v1/configuration/<em>ComponentId</em>/DataSelection</td>
<td><code>PUT</code></td>
<td>Configures or updates the Modbus TCP data selection configuration</td>
</tr>
<tr>
<td>api/v1/configuration/<em>ComponentId</em>/DataSelection</td>
<td><code>DELETE</code></td>
<td>Deletes the Modbus TCP data selection configuration</td>
</tr>
<tr>
<td>api/v1/configuration/<em>ComponentId</em>/DataSelection</td>
<td><code>PATCH</code></td>
<td>Allows partial updating of configured data selection items. <br><strong>Note:</strong> The request must be an array containing one or more data selection items. Each data selection item in the array must include its <code>StreamId</code></td>
</tr>
<tr>
<td>api/v1/configuration/<em>ComponentId</em>/DataSelection/<em>StreamId</em></td>
<td><code>PUT</code></td>
<td>Updates or creates a new data selection with the specified <em>StreamId</em></td>
</tr>
<tr>
<td>api/v1/configuration/<em>ComponentId</em>/DataSelection/<em>StreamId</em></td>
<td><code>DELETE</code></td>
<td>Deletes a specific data selection item of the Modbus TCP data selection configuration</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> Replace <code>ComponentId</code> with the Id of your Modbus TCP component. For example, <code>Modbus1</code>.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/osisoft/PI-Adapter-Modbus-Docs/blob/adapter-doc-yml/V1/Configuration/pi-adapter-for-modbus-tcp-data-selection-configuration.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span><a href="https://www.osisoft.com/copyright/">© 2019 - 2020 OSIsoft, LLC. All rights reserved.</a></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
